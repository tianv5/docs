{"./":{"url":"./","title":"Introduction","keywords":"","body":"文档 "},"books/elk/":{"url":"books/elk/","title":"ElasticSearch","keywords":"","body":"ELK Guide ElasticSearch 官方文档 7.10 "},"books/elk/analyzer_test.html":{"url":"books/elk/analyzer_test.html","title":"分析器","keywords":"","body":"分析器测试 我们先快速测试一个分析器, 从而快速体验分析器的作用. ```shell script POST _analyze { \"analyzer\": \"whitespace\", # 指定分析器,这里是内置的，空格分割. \"text\": \"The quick brown fox.\" # 需要分析的文本 } 返回结果如下 包含`token词元`,起始结束位置,type类型,和排序位置. 为了方面后面学习,和节省文本空间,我们返回结果适用 `[\"The\", \"quick\", \"brown\", \"fox.\"]`代替 ```shell script { \"tokens\": [ { \"token\": \"The\", \"start_offset\": 0, \"end_offset\": 3, \"type\": \"word\", \"position\": 0 }, { \"token\": \"quick\", \"start_offset\": 4, \"end_offset\": 9, \"type\": \"word\", \"position\": 1 }, { \"token\": \"brown\", \"start_offset\": 10, \"end_offset\": 15, \"type\": \"word\", \"position\": 2 }, { \"token\": \"fox.\", \"start_offset\": 16, \"end_offset\": 20, \"type\": \"word\", \"position\": 3 } ] } "},"books/elk/analyzer_config_buildin.html":{"url":"books/elk/analyzer_config_buildin.html","title":"配置内置分析器","keywords":"","body":"配置一个build-in分析器 https://www.elastic.co/guide/en/elasticsearch/reference/7.10/configuring-analyzers.html "},"books/elk/analyzer_custom.html":{"url":"books/elk/analyzer_custom.html","title":"自定义分析器","keywords":"","body":"自定义分析器 https://www.elastic.co/guide/en/elasticsearch/reference/7.10/analysis-custom-analyzer.html "},"books/elk/analyzer_specify.html":{"url":"books/elk/analyzer_specify.html","title":"指定分析器","keywords":"","body":"官网地址 Specify an analyzer | Elasticsearch Guide [7.10] | Elastic Elasticsearch 如何确定索引分析器 Elasticsearch 通过按顺序检查以下参数来确定要使用的索引分析器： 字段的分析器映射参数。请参阅为字段指定分析器。 索引设置。请参阅指定索引的默认分析器。analysis.analyzer.default 如果未指定这些参数，则使用标准分析器。 来自 https://www.elastic.co/guide/en/elasticsearch/reference/7.10/specify-analyzer.html Elasticsearch 如何确定搜索分析器 在搜索时，Elasticsearch 通过按顺序检查以下参数来确定要使用的分析器： 搜索查询中的分析器参数。请参阅为查询指定搜索分析器。 字段的search_analyzer映射参数。请参阅为字段指定搜索分析器。 索引设置。请参阅为索引指定默认搜索分析器。analysis.analyzer.default_search 字段的分析器映射参数。请参阅为字段指定分析器。 如果未指定这些参数，则使用标准分析器。 来自 https://www.elastic.co/guide/en/elasticsearch/reference/7.10/specify-analyzer.html 指定分析器的几种方式示例 创建索mappings时,为某个字段指定分析器 @1 为索引设置默认的分析器. @2 查询时,查询某字段,指定搜索分析器 @3 (不推荐单独指定,除非充分的测试,否则建议搜索和索引统一分析器) 创建mappings时,为某个字段指定搜索分析器. @4 创建mappings时,为搜索指定默认分析器 @5 2两种,是倒排索引时,使用的分析器. 后3种,是搜索时,分词查询时候的分析器. 如果不设置搜索分析器,则默认使用索引分析器. # @1 # 为索引某个字段指定分析器 PUT my-index-000001 { \"mappings\": { \"properties\": { \"title\": { \"type\": \"text\", \"analyzer\": \"whitespace\" } } } } # @2 # 为索引指定默认的分析器 PUT my-index-000001 { \"settings\": { \"analysis\": { \"analyzer\": { \"default\": { \"type\": \"simple\" } } } } } # @3 # 为搜索某个字段查询指定分析器 GET my-index-000001/_search { \"query\": { \"match\": { \"message\": { \"query\": \"Quick foxes\", \"analyzer\": \"stop\" } } } } # @4 # 创建mappings时候，为某个字段指定搜索分析器 PUT my-index-000001 { \"mappings\": { \"properties\": { \"title\": { \"type\": \"text\", \"analyzer\": \"whitespace\", \"search_analyzer\": \"simple\" } } } } # @5 # 创建mapping时,指定默认分析器 PUT my-index-000001 { \"settings\": { \"analysis\": { \"analyzer\": { \"default\": { \"type\": \"simple\" }, \"default_search\": { \"type\": \"whitespace\" } } } } } "},"books/elk/mapping中字段属性index,store,copy_to,enable概念.html":{"url":"books/elk/mapping中字段属性index,store,copy_to,enable概念.html","title":"mapping中字段属性 index,store,copy_to,enable的概念","keywords":"","body":"mapping中字段属性 index,store,copy_to,enable概念 参考: 关于es映射mapping中的enabled，store，index参数的理解 - Elastic 中文社区 (elasticsearch.cn) index 默认情况下, 所有字段都会创建倒排索引,可以通过字段index参数进行设置,默认true 如果设置为false，该字段将不能被查询,查询会报错,但是会存被store 当该文档被查询出来的时候,也会显示在_source中 # 首先创建一个索引, name和title字段, 其中, name的index=false PUT my_index { \"mappings\": { \"properties\": { \"name\": { \"type\": \"text\", \"index\": false }, \"title\": { \"type\": \"text\" } } } } # 创建文档,id随机, POST my_index/_doc { \"name\": \"张三\", \"title\": \"法外狂徒\" } POST my_index/_doc { \"name\": \"李四\", \"title\": \"亚洲舞王\" } 下面进行查询 POST my_index/_search { \"query\": { \"prefix\": { \"name\": { \"value\": \"张\" } } } } POST my_index/_search { \"query\": { \"prefix\": { \"title\": { \"value\": \"法\" } } } } store 默认false. 我们一般查询数据,结果都在hit中的_source字段内. 使用store=ture后,数据在_source中的不受影响,且会额外store一份在fields中. 当查询语句中加入stored_fields时，返回数据不在是_source形式,而是fields形式.下面看例子 # 删除上面index的测试索引 DELETE my_index # 重新创建索引 PUT my_index { \"mappings\": { \"properties\": { \"name\": { \"type\": \"keyword\", \"store\": true }, \"title\": { \"type\": \"keyword\" } } } } # 插入两条数据 POST my_index/_doc/1 { \"name\": \"张三\", \"title\": \"法外狂徒\" } POST my_index/_doc/2 { \"name\": \"李四\", \"title\": \"亚洲舞王\" } # 平时那样,正常使用没问题,结果没变化 POST my_index/_search { \"query\": { \"term\": { \"name\": { \"value\": \"张三\" } } } } # 查询加入 stored_fields * 也可以写name或者title,或者 [\"name\",\"title\"] # 但是title没有值,因为title的sotre=false POST my_index/_search { \"stored_fields\": [\"*\"], \"query\": { \"term\": { \"title\": { \"value\": \"亚洲舞王\" } } } } 返回结果如下 copy_to 上面来看store有点鸡肋呀, 配合copy_to很有用,因为copy_to的字段不被存储在_source中.这时候使用store:true,就可以查询使用copy_to的字段了. 还有些另外的解释,可以看 ES stored fields作用_云川之下的博客-CSDN博客_stored_fields 为了提高效率,减小传输体积,可以返回指定字段，使用\"_source\": [\"字段1\",\"字段2\"] 也可以考虑将\"字段1\",\"字段2\"这些field设置成store=true 下面我们来测试一下 copy_to 和 store copy_to 可以查阅官方文档 copy_to | Elasticsearch Guide [8.3] | Elastic DELETE my_index # 切记, copy_to 是将当前的字段值复制给目标字段 # 下面例子,理解为将当title值复制给name # 不要理解为 title的值,从name中copy, 那样应该叫copy_from,哈哈,开个玩笑,这里就搞错了.试了好几次。 PUT my_index { \"mappings\": { \"properties\": { \"name\": { \"type\": \"keyword\", \"store\": true }, \"title\": { \"type\": \"keyword\", \"copy_to\": \"name\" } } } } # 创建数据 POST my_index/_doc/1 { \"name\": \"张三\", \"title\": \"法外狂徒\" } POST my_index/_doc/2 { \"title\": \"亚洲舞王\" } GET my_index/_doc/1 GET my_index/_doc/2 # 下面两个,都能查到数据,但是_source里只展示了title,没有name. # 虽然不现实,但是还是能使用查询的. POST my_index/_search {\"query\":{\"term\":{\"title\":{\"value\":\"亚洲舞王\"}}}} POST my_index/_search {\"query\":{\"term\":{\"name\":{\"value\":\"亚洲舞王\"}}}} # copy_to 和 store联合使用, 就可以查到 # 可以查到name的值 # title换成name也一样 POST my_index/_search { \"stored_fields\": [\"name\",\"title\"], \"query\": { \"term\": { \"title\": { \"value\": \"亚洲舞王\" } } } } enable 默认是true enable 只适用于 type为object，当然,使用enable时候,可以不设置类型,因为设置了enable,就默认type为object了 enable:false表示字段不能查询,也不能被store store index 和 enable "},"books/redis/":{"url":"books/redis/","title":"Redis","keywords":"","body":"Redis 知识目录 "},"books/redis/Redis知识点整理.html":{"url":"books/redis/Redis知识点整理.html","title":"Redis知识点整理","keywords":"","body":"REDIS 数据类型 数据结构 简单来说,底层数据结构一种6种. 动态字符串 双向链表 压缩列表 哈希表 跳表 整数数组 数据类型 string 字符串 list 列表 hash 字典 sorted set 有序集合 set 集合 键和值 用什么结构组织？ REDIS 使用了一个哈希表来保存键值对. 一个哈希表,其实就是一个数组。而数组的每一个元素，称为一个哈希桶。 哈希桶内保存了键值对数据。其中，哈希桶内保存的键值对数据，并不是本身，而是具体值的指针。 这个是REDIS的全局哈希表。 哈希时，操作复杂度是O（1）。 解决哈希冲突 REDIS 解决哈希冲突的方式，就是链式哈希。 链式哈希，就是同一个哈希桶中，多个元素，用一个列表来保存。 元素之间，用指针链接。 引入问题: 就是链式哈希存储过多的entry,导致效率降低。 解决问题： REHASH REHASH 其实就是扩容, 增加哈希桶的数量。从而让entry存储的更加分散。 存在同一个哈希桶中的过多的元素, 也可以分散开来。 REDIS为了增加REHASH的效率，其实使用了2个全局哈希表。 使用哈希表1,当数据足够多时,申请哈希表2的空间是1的2倍。 把哈希表1中的数据，映射到哈希表2中 使用哈希表2，释放哈希表1 下次往复操作。 上面的操作中, 步骤2会拷贝大量数据，从到造成REDIS线程阻塞，为了避免这个问题，采用了渐进式的REHASH 渐进式操作，其实就是再处理请求时，每次处理请求的同时，顺带着完成一次索引位置(哈希桶)的copy(表1映射到表2)。 当哈希表从头copy,到表尾时，也就完成了copy. ps. 同时可以同时操作哈希表1和哈希表2. 避免新数据未拷贝，类似数据库迁移，数据写入存2份。 Redis基于单线程,为什么快？ 首先强调, 多线程不一定快, 因为cpu频繁的线程间上下文切换,会增加性能消耗. 其次, 我们常说的Redis的单线程, 是指处理网络请求的模块,是一个IO多路复用的单线程. 即保证处理效率,又省去并发的安全性. 其他模块仍然使用了多个线程. 好了，继续说, Redis为什么快？ Redis大部分操作,在内存中完成, 内存的读写速度很快,再加上Redis采用的高效的数据结构，保证了效率. 第二点就是,单线程采用了 多路复用机制. 什么是多路复用? IO多路复用,就是我们常说的select/epoll机制. 该机制允许内核中,同时存在多个监听套接字和连接套接字 内核会一直监听这些套接字上的连接请求或数据请求。 一旦请求到达，就会交给Redis线程处理，这就实现了一个Redis线程处理多个IO流的效果。 为了在请求达到后 能及时通知Redis线程, select/epoll提供了基于事件的回调机制, 只要检测到FD上有请求达到，就会触发相应的事件。 这些事件会放进一个队列，Redis线程对这个队列不断进行处理。 Redis处理事件时候，会调用相应的处理函数，就实现了基于事件的回调。 Redis无需一直轮询是否有请求，避免了CPU的浪费。 "},"books/python/":{"url":"books/python/","title":"Python","keywords":"","body":"python 快速回顾 "},"books/python/装饰器.html":{"url":"books/python/装饰器.html","title":"装饰器","keywords":"","body":"装饰器概念 一个简单的语法糖，或者说是一个特殊的高阶函数. 通过保证目标函数来修改其行为, 绝大多数装饰器 都是通过闭包的原理 来实现的. @cache def function():.... 等同于 def function():... function = cache(function) 无参数的装饰器 \"\"\" 没有参数的装饰器 功能: 打印包装函数的执行时间 \"\"\" import time def timer(func): def decorated(*args, **kwargs): st = time.perf_counter() ret = func(*args, **kwargs) print(\"cost time\", time.perf_counter() - st) return ret return decorated @timer def sleep_func(): time.sleep(1) if __name__ == '__main__': sleep_func() 有参数的装饰器 给刚才的timer装饰器,加上print_agrs参数,是否打印参数 \"\"\" 没有参数的装饰器 功能: 打印包装函数的执行时间 \"\"\" import time def timer(print_args=False): def decorated(func): def wrapper(*args, **kwargs): st = time.perf_counter() ret = func(*args, **kwargs) if print_args: print(\"调用参数\", args, kwargs) print(\"cost time\", time.perf_counter() - st) return ret return wrapper # 带参数,外层其实是个保证,返回装饰器函数 return decorated @timer(print_args=True) def sleep_func(port, ip=\"127.0.0.1\"): \"\"\"文档注释\"\"\" time.sleep(1) if __name__ == '__main__': sleep_func(8888) print(sleep_func.__name__) help(sleep_func) # 这是因为装饰器再包装目标函数的时候，丢失了函数的元信息，是一种副作用 # 函数名字和help信息都丢了 functools.wraps 可以 \"\"\" 相当于 _decorated = timer(print_args=True) sleep_func = _decorated(sleep_func) 或 sleep_func = timer(print_args=True)(sleep_func) 有参数的装饰器明显难写了不少, 可以看到, 我们比无参数的装饰器多调用了一次,实现代码也多了一层函数嵌套. 后面我们会用类来实现有参数的装饰器,可以明显较少代码嵌套的层数 \"\"\" 使用functools.wraps()修饰包装函数 import time from functools import wraps def timer(print_args=False): def decorated(func): # 新增到这,加到被装饰的函数 @wraps(func) def wrapper(*args, **kwargs): st = time.perf_counter() ret = func(*args, **kwargs) if print_args: print(\"调用参数\", args, kwargs) print(\"cost time\", time.perf_counter() - st) return ret return wrapper return decorated @timer(print_args=True) def sleep_func(port, ip=\"127.0.0.1\"): \"\"\"文档注释\"\"\" time.sleep(1) if __name__ == '__main__': sleep_func(8888) print(sleep_func.__name__) help(sleep_func) 类装饰器 类装饰器,主要运用__call__可调用对象这个特性 import time from functools import wraps class Timer: def __init__(self, print_args): self.print_args = print_args def __call__(self, func): @wraps(func) def decorated(*args, **kwargs): s = time.time() ret = func(*args, **kwargs) if self.print_args: print(ret) print(time.time() - s) return ret return decorated @Timer(False) def hello(): time.sleep(1) return \"www\" if __name__ == '__main__': hello() 另一种方式实现类装饰器 import time from functools import wraps, update_wrapper class Timer: def __init__(self, func): update_wrapper(self, func) self.func = func def __call__(self, *args, **kwargs): s = time.time() ret = self.func(*args, **kwargs) print(time.time() - s) return ret @Timer def hello(): time.sleep(1) return \"www\" if __name__ == '__main__': hello() 再加一种 import time from functools import wraps, update_wrapper, partial class Timer: def __init__(self, func, *, args1=None): update_wrapper(self, func) self.func = func self.args1 = args1 def __call__(self, *args, **kwargs): s = time.time() ret = self.func(*args, **kwargs) print(time.time() - s) print(self.args1) return ret def delayed_start(**kwargs): return partial(Timer, **kwargs) @delayed_start(args1=\"ccc\") def hello(): time.sleep(1) return \"www\" if __name__ == '__main__': hello() "},"books/数据结构与算法/0.大O.html":{"url":"books/数据结构与算法/0.大O.html","title":"数据结构与算法","keywords":"","body":"数据结构与算法 大O 英文order of （大约） 大O 可以告诉我们算法的快慢,比较的是操作数,运行时间的增速。 大O 具体描述了最坏的情况 "},"books/数据结构与算法/01.线性结构.html":{"url":"books/数据结构与算法/01.线性结构.html","title":"1.线性结构-数组array","keywords":"","body":"线性结构-数组array python内置了一个 array 模块,但是我们大多数都不用它,使用的是list array 内存分配的时候是连续的 、存储的同一类型的数据, 只能存数值和字符串,不能存储复杂对象的一种结构. 简单实现 Array 扩展,比如申请内存,空间翻倍等, 可以自己添加. "},"books/数据结构与算法/02.链式结构-单链表.html":{"url":"books/数据结构与算法/02.链式结构-单链表.html","title":"2.链式结构-单链表","keywords":"","body":"链式结构 内存空间不在需要连续 n : next 存储的是下一个值的地址 t: 上一个值的地址 v: 值的数值存储 有n有t,是双向链表结构 只有n,是单向链表结构 在头部加数据, O(1) 删除任意一个元素的时候,n2指向v3即可,效率也很高. 如果查看v2元素是什么时候,效率就不高了,只能从第一个往下找. 代码模拟链表 # 节点对象,value和next class Node: def __init__(self, value=None, next_=None): self.value = value self.next_ = next_ def __str__(self): return f\"Node: {self.value}\" # 链式结构 class LinkedList: def __init__(self): # 初始化根节点,根节点无数据,每次遍历都是从这里去观察, # 不管是在链表前 还是后加数据,都是在root.next_后面 self.root = Node() # 记录链式结构的大小 self.size = 0 # 最后一个节点,增加新数据时, 放在这个数据后面. self.end = None # 向尾部加值 def append(self, value): node = Node(value) if not self.end: # 检查下一个节点是否存在,不存在,则表示此时还无数据. self.root.next_ = node # 指定root的next_为node else: self.end.next_ = node # 已经有数据,指定下一个节点的next_为node self.end = node self.size += 1 def append_first(self, value): node = Node(value) if not self.end: # 没有节点的时候 self.root.next_ = node self.end = node else: # 有节点的时候 t = self.root.next_ # 原来root后面的节点.第一个节点 self.root.next_ = node # 设置新的第一个节点 node.next_ = t # 新的第一个节点 -> 原来的第一个节点 self.size += 1 def __iter__(self): current = self.root.next_ if current: # 如果不是最后一个节点,就继续遍历 while current is not self.end: yield current current = current.next_ yield current def find(self, value): for n in self: if n.value == value: return f\"{n} {id(n)}\" def count(self, value): c = 0 for n in self: if n.value == value: c += 1 return c def remove(self, value): # 上一个节点 prev = self.root for n in self: if n.value == value: # 上一个节点 -> 链接 下一个节点 if n == self.end: prev.next_ = None self.end = prev else: prev.next_ = n.next_ del n self.size -= 1 return True # 更新上一个节点 prev = n def remove_all(self, value): # 上一个节点 prev = self.root for n in self: if n.value == value: # 上一个节点 -> 链接下一个节点 if n == self.end: prev.next_ = None self.end = prev else: prev.next_ = n.next_ del n self.size -= 1 continue # 更新上一个节点 prev = n if __name__ == '__main__': link = LinkedList() link.append(\"孙悟空\") link.append(\"猪八戒1\") link.append(\"猪八戒1\") link.append(\"猪八戒\") for v in link: print(v) link.remove_all(\"猪八戒1\") print(\"--------------\") for v in link: print(v) "},"books/github_pages/":{"url":"books/github_pages/","title":"github pages","keywords":"","body":"github pages 搭建网站 GitHub Pages 是一个静态站点托管服务。 可以展示静态网站,打开此功能. 可以通过https://用户名.github.io/项目名访问此项目的静态页面,首页为index.html 此类项目可以创建多个. 还可以创建 用户名.github.io 的项目名, 访问https://用户名.github.io 即可 但此类github pages只能创建一个,不能像上面的创建多个. 可以使用 hexo, hugo, gitbook, mkdocs 等快速构建你的静态页面网站. "},"books/github_pages/gitbook构建网站.html":{"url":"books/github_pages/gitbook构建网站.html","title":"gitbook构建网站","keywords":"","body":"gitbook环境准备 # 安装nodejs, 因为gitbook根据依赖,且gitbook不再维护更新,需要node.js 10.21.0以下 # 下载并安装 https://nodejs.org/download/release/v10.12.0/ # 设置npm源 npm config set registry https://registry.npm.taobao.org # 切换到官方源 npm config set registry http://www.npmjs.org # 查看源 npm get registry # 安装命令行工具 npm install -g gitbook-cli # 会自动安装gitbook gitbook -V # 再次执行,提示这个版本说明安装成功了 # 因为已经停止维护了,最新的版本就是这个了. gitbook -V CLI version: 2.3.2 GitBook version: 3.2.3 创建项目 # 创建文件夹, 这个就是gitbook的项目目录 mkdir book # 初始化 cd book gitbook init # 打包 默认打包到_book gitbook build # 启动服务, 默认_book gitbook server # 访问默认地址 http://localhost:4000/ 目录说明 # 项目创建,生成SUMMARY.md和README.md SUMMARY.md 项目 README.md 首页 book.js 其实官方使用的是 book.json,我们使用npm管理,module.exports输出一个json .bookignore 构建时忽略的文件,防止_book文件太大,多余的不进行打包 插件安装 npm install gitbook-plugin-search-pro npm install gitbook-plugin-chapter-fold npm install gitbook-plugin-sitemap npm install gitbook-plugin-theme-lou npm install gitbook-plugin-back-to-top-button npm install gitbook-plugin-code npm install gitbook-plugin-prism 文件内容 book.js module.exports = { \"title\": \"我的文档\", \"author\": \"tianv5\", \"description\": \"文档\", \"keywords\": \"学习,笔记,编程,代码,博客,文章,github\", \"introduction\": { \"path\": \"README.md\", \"title\": \"前言\", }, \"variables\": { \"themeColor\": \"#3884ff\", \"themeLou\": { // 顶部导航栏配置 \"nav\": [ { \"target\": \"_blank\", // 跳转方式: 打开新页面 \"url\": \"https://www.baidu.com\", // 跳转页面 \"name\": \"百度\" // 导航名称 } ] } }, \"plugins\": [ \"-highlight\", \"-lunr\", \"-search\", \"-sharing\", \"-livereload\", \"search-pro\", \"chapter-fold\", \"sitemap\", \"theme-lou\", \"back-to-top-button\", \"code\", \"prism\" ], \"pluginsConfig\": { \"chapter-fold\": {}, \"theme-lou\": { \"color\": \"#5F9EA0\", // 主题色 \"favicon\": \"static/favicon.ico\", // favicon图标 \"logo\": \"static/logo.png\", // 顶部左侧图标 \"forbidCopy\": false, // 页面是否禁止复制 \"search-placeholder\": \"全局搜索\", // 搜索框默认文本 \"book-summary-title\": \"导航\", // 目录标题 \"book-anchor-title\": \"本章目录标题\", // 本章目录标题 \"hide-elements\": [\".summary .gitbook-link\"], \"imgStyle\": { \"isCenter\": true, // 是否居中(默认为true) \"isBox\": false, // 是否有边框(默认为true) \"otherStyle\": 'max-width: 80%;', // 图片其他自定义CSS样式 } }, \"sitemap\": { \"hostname\": \"https://tianv5.github.io/docs\" }, \"prism\": { \"css\": [ \"prismjs/themes/prism-okaidia.css\" ], \"lang\": { \"flow\": \"typescript\" } } }, \"pdf\": { \"toc\": true, \"pageNumbers\": true, \"fontSize\": 12, \"paperSize\": \"a4\", \"margin\": { \"right\": 62, \"left\": 62, \"top\": 36, \"bottom\": 36 } } } ; .gitignore .idea _book node_modules .bookignore package.json package-lock.json .bookignore .gitignore Summary.md 目录和文件不要有空格等特殊符号 不然目录跳转容易有问题 # Summary ## 简介 * [前言](README.md) ## 中间件 * [ElasticSearch](blog/elk/elk.md) * [index,store,copy_to,enable的概念](blog/elk/mapping01.md) ## 其他 * [gitbook教程](blog/gitbook教程/gitbook教程.md) * [插件的使用](blog/gitbook教程/插件的使用.md) "},"books/github_pages/GitHubActions.html":{"url":"books/github_pages/GitHubActions.html","title":"github Actions自动构建","keywords":"","body":"GitHub Actions CI/CD的工具 当我们提交代码的时候,可以触发流水线. 我们的目的是自动构建 gitbook build,并将编译好的代码静态页面提交到个人仓库中, 并自动更新到github pages. 配置secrets 首先在项目内新增一个秘钥token,给流水线使用,注意这个token有失效,可以设置无限期. 项目的settings -> Secrets -> Actions -> New repository secret CI脚本 工作流程在 .github/workflows 目录中定义,此目录下所有yml文件都会被执行. .github/workflows/ci.yml 如我们的文件编辑如下 当我们推送代码,触发Actions时 切换到主分支main 安装node.js 因为我们的gitbook依赖 安装gitbook 安装gitbook服务需要的各种插件 执行git build,生成_book目录 将_book目录内容,推送到仓库的gh-pages分支 做完以上步骤,github pages也会触发一个流水线,将gh-pages内容更新. name: auto-generate-gitbook on: #在main分支上进行push时触发 push: branches: - main jobs: main-to-gh-pages: runs-on: ubuntu-latest steps: - name: checkout main uses: actions/checkout@v2 with: ref: main - name: install nodejs uses: actions/setup-node@v1 - name: configue gitbook run: | npm install -g gitbook-cli npm install gitbook-plugin-search-pro npm install gitbook-plugin-chapter-fold npm install gitbook-plugin-sitemap npm install gitbook-plugin-theme-lou npm install gitbook-plugin-back-to-top-button npm install gitbook-plugin-code npm install gitbook-plugin-prism - name: generate _book folder run: | gitbook build cp SUMMARY.md _book - name: push _book to branch gh-pages env: TOKEN: ${{ secrets.TOKEN }} REF: github.com/${{github.repository}} MYEMAIL: xxxxxxxxx@qq.com # ！！！ 记得修改为自己github设置的邮箱 MYNAME: ${{github.repository_owner}} run: | cd _book git config --global user.email \"${MYEMAIL}\" git config --global user.name \"${MYNAME}\" git init git remote add origin https://${REF} git add . git commit -m \"Updated By Github Actions With Build ${{github.run_number}} of ${{github.workflow}} For Github Pages\" git branch -M main git push --force --quiet \"https://${TOKEN}@${REF}\" main:gh-pages "}}