## REDIS 数据类型



**数据结构**

简单来说,底层数据结构一种6种.

- 动态字符串
- 双向链表
- 压缩列表
- 哈希表
- 跳表
- 整数数组



**数据类型**

- string  字符串
- list 列表
- hash 字典
- sorted set 有序集合
- set 集合



 ![数据结构关系图](https://public-1257059699.cos.ap-beijing.myqcloud.com/PicGo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg)







## 键和值 用什么结构组织？



REDIS 使用了一个哈希表来保存键值对.

一个哈希表,其实就是一个数组。而数组的每一个元素，称为一个哈希桶。

哈希桶内保存了键值对数据。其中，哈希桶内保存的键值对数据，并不是本身，而是具体值的指针。

这个是REDIS的`全局哈希表`。  哈希时，操作复杂度是O（1）。

 ![全局哈希表](https://public-1257059699.cos.ap-beijing.myqcloud.com/PicGo/%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.png)



## 解决哈希冲突

REDIS 解决哈希冲突的方式，就是链式哈希。

链式哈希，就是同一个哈希桶中，多个元素，用一个列表来保存。

元素之间，用指针链接。

引入问题: 

 就是链式哈希存储过多的entry,导致效率降低。

解决问题：

REHASH

 ![链式哈希解决哈希冲突](https://public-1257059699.cos.ap-beijing.myqcloud.com/PicGo/%E9%93%BE%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81.png)





## REHASH 

其实就是扩容,  增加哈希桶的数量。从而让entry存储的更加分散。

存在同一个哈希桶中的过多的元素, 也可以分散开来。

REDIS为了增加REHASH的效率，其实使用了2个全局哈希表。

1.  使用哈希表1,当数据足够多时,申请哈希表2的空间是1的2倍。
2. 把哈希表1中的数据，映射到哈希表2中
3. 使用哈希表2，释放哈希表1
4. 下次往复操作。



上面的操作中,  步骤2会拷贝大量数据，从到造成REDIS线程阻塞，为了避免这个问题，采用了渐进式的REHASH

渐进式操作，其实就是再处理请求时，每次处理请求的同时，顺带着完成一次索引位置(哈希桶)的copy(表1映射到表2)。

当哈希表从头copy,到表尾时，也就完成了copy.

ps. 同时可以同时操作哈希表1和哈希表2. 避免新数据未拷贝，类似数据库迁移，数据写入存2份。





